-- Partitioning Migration Script for 'prices' table (v2)
-- Created: 2025-12-30
-- Strategy: Range Partitioning (Monthly)

BEGIN;

-- 1. Rename existing table and indexes to avoid conflicts
ALTER TABLE prices RENAME TO prices_old;

-- Explicitly rename constraints colliding with new table
ALTER TABLE prices_old RENAME CONSTRAINT prices_pkey TO prices_old_pkey;
ALTER TABLE prices_old RENAME CONSTRAINT valid_price TO prices_old_valid_price;
-- Rename unique constraint if it exists
DO $$
BEGIN
    IF EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'prices_unique_key') THEN
        ALTER TABLE prices_old RENAME CONSTRAINT prices_unique_key TO prices_old_unique_key;
    END IF;
END $$;

-- 2. Create the new Partitioned Master Table
CREATE TABLE prices (
    id                  BIGINT GENERATED BY DEFAULT AS IDENTITY, -- New identity sequence
    product_id          BIGINT NOT NULL,
    supplier_id         INTEGER NOT NULL,
    store_id            INTEGER,
    price               NUMERIC(12,2) NOT NULL,
    currency            CHAR(3) DEFAULT 'USD',
    is_available        BOOLEAN DEFAULT TRUE,
    
    -- Metadata
    scraped_at          TIMESTAMP WITHOUT TIME ZONE DEFAULT NOW(),
    first_scraped_at    TIMESTAMP WITHOUT TIME ZONE NOT NULL DEFAULT NOW(),
    last_scraped_at     TIMESTAMP WITHOUT TIME ZONE,
    is_verified         BOOLEAN DEFAULT FALSE,
    is_suspicious       BOOLEAN DEFAULT FALSE,
    is_sandbox          BOOLEAN DEFAULT FALSE,
    
    -- Product Details
    original_price      NUMERIC(12,2),
    discount_percentage NUMERIC(5,2),
    quantity            INTEGER DEFAULT 1,
    unit                VARCHAR(50) DEFAULT 'piece',
    is_on_sale          BOOLEAN DEFAULT FALSE,
    sale_ends_at        TIMESTAMP WITHOUT TIME ZONE,
    stock_level         VARCHAR(50),
    shipping_cost       NUMERIC(10,2),
    free_shipping       BOOLEAN DEFAULT FALSE,
    source_url          VARCHAR(1000),
    scrape_job_id       UUID,
    
    -- Relations
    master_product_id   BIGINT,
    promo_description   TEXT,
    is_sale             BOOLEAN DEFAULT FALSE,
    price_regular       NUMERIC(10,2),
    is_starting_price   BOOLEAN DEFAULT FALSE,

    -- Partition Key Requirement: PK must include the partition key
    CONSTRAINT prices_pkey PRIMARY KEY (id, scraped_at),
    CONSTRAINT valid_price CHECK (price >= 0)
) PARTITION BY RANGE (scraped_at);

-- 3. Create Partitions
CREATE TABLE prices_default PARTITION OF prices DEFAULT;
CREATE TABLE prices_2024_10 PARTITION OF prices FOR VALUES FROM ('2024-10-01') TO ('2024-11-01');
CREATE TABLE prices_2024_11 PARTITION OF prices FOR VALUES FROM ('2024-11-01') TO ('2024-12-01');
CREATE TABLE prices_2024_12 PARTITION OF prices FOR VALUES FROM ('2024-12-01') TO ('2025-01-01');
CREATE TABLE prices_2025_01 PARTITION OF prices FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');
CREATE TABLE prices_2025_02 PARTITION OF prices FOR VALUES FROM ('2025-02-01') TO ('2025-03-01');
CREATE TABLE prices_2025_03 PARTITION OF prices FOR VALUES FROM ('2025-03-01') TO ('2025-04-01');

-- 4. Restore Foreign Keys
ALTER TABLE prices ADD CONSTRAINT fk_prices_product 
    FOREIGN KEY (product_id) REFERENCES products(id) ON DELETE CASCADE;
    
ALTER TABLE prices ADD CONSTRAINT fk_prices_supplier 
    FOREIGN KEY (supplier_id) REFERENCES suppliers(id) ON DELETE CASCADE;

ALTER TABLE prices ADD CONSTRAINT fk_prices_store 
    FOREIGN KEY (store_id) REFERENCES stores(id);

ALTER TABLE prices ADD CONSTRAINT fk_prices_currency 
    FOREIGN KEY (currency) REFERENCES currencies(code);

ALTER TABLE prices ADD CONSTRAINT fk_prices_master 
    FOREIGN KEY (master_product_id) REFERENCES master_products(id);

-- 5. Restore Indexes (On Parent)
CREATE INDEX idx_prices_lookup_v2 ON prices (product_id, supplier_id, store_id, scraped_at DESC);
CREATE INDEX idx_prices_scraped_at_v2 ON prices (scraped_at DESC);
CREATE INDEX idx_prices_product_history ON prices (product_id, scraped_at DESC);
CREATE INDEX idx_prices_store_active ON prices (store_id, is_available) WHERE is_available = TRUE;

-- 6. Data Migration
-- Copy data from old table to new partitioned table.
INSERT INTO prices (
    id, product_id, supplier_id, store_id, price, currency, is_available,
    scraped_at, first_scraped_at, last_scraped_at, is_verified, is_suspicious, is_sandbox,
    original_price, discount_percentage, quantity, unit, is_on_sale, sale_ends_at,
    stock_level, shipping_cost, free_shipping, source_url, scrape_job_id,
    master_product_id, promo_description, is_sale, price_regular, is_starting_price
)
SELECT 
    id, product_id, supplier_id, store_id, price, currency, is_available,
    COALESCE(scraped_at, NOW()), first_scraped_at, last_scraped_at, is_verified, is_suspicious, is_sandbox,
    original_price, discount_percentage, quantity, unit, is_on_sale, sale_ends_at,
    stock_level, shipping_cost, free_shipping, source_url, scrape_job_id,
    master_product_id, promo_description, is_sale, price_regular, is_starting_price
FROM prices_old;

-- 7. Sync Sequence
SELECT setval(pg_get_serial_sequence('prices', 'id'), (SELECT MAX(id) FROM prices_old));

COMMIT;
