# ============================================================================
# Gogobe Global Load Balancer - Nginx Configuration
# Routes traffic to healthy regions with automatic failover
# ============================================================================

events {
    worker_connections 10000;
    use epoll;
}

http {
    # Logging
    access_log /var/log/nginx/access.log;
    error_log /var/log/nginx/error.log warn;

    # Upstream definitions - Regional API Gateways
    # Each upstream has health checks and automatic failover
    
    upstream israel_api {
        least_conn;  # Load balancing method
        
        server api-israel:8000 max_fails=3 fail_timeout=30s;
        
        # Health check
        keepalive 32;
    }
    
    upstream usa_api {
        least_conn;
        
        server api-usa:8000 max_fails=3 fail_timeout=30s;
        
        keepalive 32;
    }
    
    upstream europe_api {
        least_conn;
        
        server api-europe:8000 max_fails=3 fail_timeout=30s;
        
        keepalive 32;
    }
    
    upstream asia_api {
        least_conn;
        
        server api-asia:8000 max_fails=3 fail_timeout=30s;
        
        keepalive 32;
    }
    
    # Fallback upstream - tries all regions in order
    upstream global_failover {
        # Priority order: closest region first, then fallback
        server api-israel:8000 max_fails=2 fail_timeout=10s;
        server api-usa:8000 max_fails=2 fail_timeout=10s backup;
        server api-europe:8000 max_fails=2 fail_timeout=10s backup;
        server api-asia:8000 max_fails=2 fail_timeout=10s backup;
    }

    # GeoIP mapping (simulated - in production use MaxMind GeoIP)
    map $http_x_forwarded_for $backend {
        default         global_failover;
        
        # Israel IPs → Israel region
        ~^5\.         israel_api;
        ~^37\.        israel_api;
        ~^79\.        israel_api;
        
        # USA IPs → USA region
        ~^3\.         usa_api;
        ~^4\.         usa_api;
        ~^8\.         usa_api;
        
        # Europe IPs → Europe region
        ~^2\.         europe_api;
        ~^31\.        europe_api;
        ~^46\.        europe_api;
        
        # Asia IPs → Asia region
        ~^1\.         asia_api;
        ~^14\.        asia_api;
        ~^27\.        asia_api;
    }

    # Rate limiting
    limit_req_zone $binary_remote_addr zone=api_limit:10m rate=100r/s;
    limit_req_zone $binary_remote_addr zone=search_limit:10m rate=50r/s;

    # Cache settings
    proxy_cache_path /var/cache/nginx levels=1:2 keys_zone=api_cache:100m max_size=1g inactive=60m;

    server {
        listen 80;
        server_name gogobe.com www.gogobe.com;

        # Security headers
        add_header X-Frame-Options "SAMEORIGIN" always;
        add_header X-Content-Type-Options "nosniff" always;
        add_header X-XSS-Protection "1; mode=block" always;

        # Health check endpoint
        location /health {
            access_log off;
            return 200 "healthy\n";
            add_header Content-Type text/plain;
        }

        # Global health check - checks all regions
        location /health/global {
            access_log off;
            
            # Custom Lua script to check all regions
            content_by_lua_block {
                local http = require "resty.http"
                local cjson = require "cjson"
                
                local regions = {
                    {name = "israel", host = "api-israel", port = 8000},
                    {name = "usa", host = "api-usa", port = 8000},
                    {name = "europe", host = "api-europe", port = 8000},
                    {name = "asia", host = "api-asia", port = 8000}
                }
                
                local status = {}
                local healthy_count = 0
                
                for _, region in ipairs(regions) do
                    local httpc = http.new()
                    httpc:set_timeout(1000)  -- 1 second timeout
                    
                    local res, err = httpc:request_uri(
                        "http://" .. region.host .. ":" .. region.port .. "/health",
                        {method = "GET"}
                    )
                    
                    if res and res.status == 200 then
                        status[region.name] = "healthy"
                        healthy_count = healthy_count + 1
                    else
                        status[region.name] = "unhealthy: " .. (err or "unknown")
                    end
                end
                
                status.healthy_regions = healthy_count
                status.total_regions = #regions
                status.status = healthy_count > 0 and "operational" or "down"
                
                ngx.status = healthy_count > 0 and 200 or 503
                ngx.say(cjson.encode(status))
            }
        }

        # API routes - with intelligent routing and failover
        location /api/ {
            # Rate limiting
            limit_req zone=api_limit burst=20 nodelay;

            # Try region-specific backend first, fallback to global
            proxy_pass http://$backend;
            
            # Failover configuration
            proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504;
            proxy_next_upstream_tries 3;
            proxy_next_upstream_timeout 10s;

            # Proxy headers
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header X-Region $backend;

            # Timeouts
            proxy_connect_timeout 5s;
            proxy_send_timeout 30s;
            proxy_read_timeout 30s;

            # Buffering
            proxy_buffering on;
            proxy_buffer_size 4k;
            proxy_buffers 8 4k;

            # Cache GET requests
            proxy_cache api_cache;
            proxy_cache_valid 200 5m;
            proxy_cache_valid 404 1m;
            proxy_cache_use_stale error timeout updating http_500 http_502 http_503 http_504;
            proxy_cache_background_update on;
            proxy_cache_lock on;
            
            add_header X-Cache-Status $upstream_cache_status;
            add_header X-Served-By $backend;
        }

        # Search endpoint - higher rate limit
        location /api/search {
            limit_req zone=search_limit burst=10 nodelay;

            proxy_pass http://$backend;
            proxy_next_upstream error timeout http_502 http_503 http_504;
            
            # Same proxy settings as above
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            
            # Aggressive caching for search
            proxy_cache api_cache;
            proxy_cache_valid 200 10m;
            proxy_cache_key "$scheme$request_method$host$request_uri$arg_q";
            
            add_header X-Cache-Status $upstream_cache_status;
        }

        # Static files - served from any region
        location /static/ {
            proxy_pass http://global_failover;
            proxy_cache api_cache;
            proxy_cache_valid 200 1h;
            
            expires 1h;
            add_header Cache-Control "public, immutable";
        }

        # Admin panel - Israel only (for security)
        location /admin/ {
            # IP whitelist (example)
            allow 172.21.0.0/16;  # Israel network
            deny all;
            
            proxy_pass http://israel_api;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
        }

        # Metrics endpoint (Prometheus)
        location /metrics {
            stub_status on;
            access_log off;
            
            # Only allow from monitoring network
            allow 172.20.0.0/16;
            deny all;
        }
    }

    # HTTPS server (production)
    server {
        listen 443 ssl http2;
        server_name gogobe.com www.gogobe.com;

        # SSL configuration (use Let's Encrypt in production)
        ssl_certificate /etc/nginx/ssl/cert.pem;
        ssl_certificate_key /etc/nginx/ssl/key.pem;
        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_ciphers HIGH:!aNULL:!MD5;
        ssl_prefer_server_ciphers on;

        # Same location blocks as HTTP server
        # ... (copy from above)
    }
}
